[{"title":"集成 Pjax 实现网站无刷新加载","url":"/2019/09/24/use-pjax-to-your-site/","content":"\n## 前言\n\n一般情况下，当我们点击一个网页链接后，浏览器就会努力发送网络请求，然后将请求到的网页渲染出来。有时，我们经常会在一个网站中不停地点击链接，然后网页不停地跳转。通常，浏览器会对文件资源进行一定的缓存，这样使得同一个网站之间的页面跳转时，能够更快的加载。\n\n虽然浏览器对资源的缓存加快了页面的加载速度，但是页面每一次跳转时，都会整体刷新一次，这一定程度上降低了用户体验。为了解决这一问题，我们可以使用 Pjax 实现网站无刷新加载。\n\n<!-- more -->\n\n## Pjax 原理\n\n首先要知道 `Pjax = Ajax + pushState`。当用户进行超链请求时，Pjax 会拦截请求，然后触发 Ajax 请求和 `pushState`。其中，Ajax 使你的页面局部刷新，`pushState` 用于修改 URL 而不跳转页面，从而实现不跳转页面局部刷新的功能。\n\n## 开始使用\n\nPjax 有依赖和不依赖 jQuery 的两种版本：\n\n- [defunkt/jquery-pjax](https://github.com/defunkt/jquery-pjax)【依赖于 jQuery】\n- [MoOx/pjax](https://github.com/MoOx/pjax)【推荐】\n\n这里以不依赖 jQuery 的 [MoOx/pjax](https://github.com/MoOx/pjax) 作为教程。\n\n### 引用文件\n\n为了方便，这里直接使用 JSDelivr 公共的 CDN 地址：\n\n``` html\n<script src=\"https://cdn.jsdelivr.net/npm/pjax/pjax.js\"></script>\n```\n\n### 分析页面\n\n在网站页面切换时，有些部分是不变的，有些是改变的。我们需要根据网站的 DOM 结构自行分析。举个例子，假设页面的结构如下：\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Liuyib's Blog</title>\n  <meta name=\"keywords\" content=\"liuyib, Liuyib's Blog\">\n</head>\n<body>\n  <header id=\"header\" class=\"header\">\n    顶部栏...\n  </header>\n  <main id=\"main\" class=\"main\">\n    主体部分...\n  </main>\n  <footer id=\"footer\" class=\"footer\">\n    底部栏...\n  </footer>\n</body>\n</html>\n```\n\n每次切换页面时，`title` 会随之改变，`header` 和 `footer` 一般不变，而 `main` 是网站的主体部分，也会改变。因此，我们可以这样来使用 Pjax：\n\n``` js\nvar pjax = new Pjax({\n  // 这里填写页面不变的部分（和 CSS 选择器用法一样）\n  selectors: [\n    \"head title\",\n    \"#main\"\n  ]\n});\n```\n\n这样，就实现了一个最简单的 Pjax 网站，不过这才刚开始。下面是一些常用的参数：\n\n- `elements`：默认值 `a[href], form[action]`\n\n  指定应用 Pjax 的链接。\n\n- `switches`：默认值 `{}`\n\n  使用旧元素替换新元素。\n\n- `history`：默认值 `true`\n\n  是否启用 `pushState`。禁用后 Pjax 就变成了 Ajax。\n\n- `scrollTo`：默认值 `0`\n\n  页面切换后到顶部的距离。设为 `false` 表示页面保持在切换前的位置。\n\n- `scrollRestoration`：默认值 `true`\n\n  切换页面后，Pjax 将尝试恢复滚动位置。\n\n- `cacheBust`：默认值 `true`\n\n  是否在 URL 上添加时间戳，防止浏览器缓存。\n\n关于这些参数的作用和设置，根据需要自行选择。更多参数，请查看 MoOx/pjax 项目的 [READMD](https://github.com/MoOx/pjax)。\n\n### 添加进度条\n\n使用了 Pjax 后，在进行页面跳转时，浏览器没有任何加载提示，并且在跳转完成之前，页面不会有任何变化，因此在网速比较慢的情况下，我们可能会以为页面并没有进行跳转。为了改善体验，可以添加一个进度条，以此来告诉用户“页面正在加载”。\n\n说到这里，就不得不提到 Github 的加载进度条。如果心细的同学可能会发现，Github 也使用了 Pjax。那么下面我们仿照 Github 来实现一个 Pjax 加载进度条吧。\n\n首先要清楚一点，这里要实现的加载进度条实际上是**假的**，也就是说，页面实际加载了多少我们并没有办法知道，进度条也只是按照一定的速度增加的。\n\n> 如果可以控制服务端的话，可以做出**真的**加载进度条，至少在 Github Pages 上还暂时做不到。\n\nHTML (Pug):\n\n``` html\ndiv.loading-bar\n  div.progress\n```\n\nCSS (Stylus):\n\n``` stylus\n.loading-bar {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 99999;\n  opacity: 0;\n  transition: opacity .4s linear;\n\n  .progress {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 0;\n    height: 2px;\n    background-color: #77b6ff;\n    box-shadow: 0 0 10px rgba(119, 182, 255, .7);\n  }\n\n  &.loading {\n    opacity: 1;\n    transition: none;\n\n    .progress {\n      transition: width .4s ease;\n    }\n  }\n}\n```\n\nJavaScript:\n\n``` js\nvar loadingBar = document.querySelector('.loading-bar');\nvar progress = document.querySelector('.loading-bar .progress');\nvar timer = null;\n\n// Pjax 开始时执行的函数\ndocument.addEventListener('pjax:send', function (){\n  // 进度条默认已经加载 20%\n  var loadingBarWidth = 20;\n  // 进度条的最大增加宽度\n  var MAX_LOADING_WIDTH = 95;\n\n  // 显示进度条\n  loadingBar.classList.add('loading');\n  // 初始化进度条的宽度\n  progress.style.width = loadingBarWidth + '%';\n\n  clearInterval(timer);\n  timer = setInterval(function () {\n    // 进度条的增加速度（可以改为一个随机值，显得更加真实）\n    loadingBarWidth += 3;\n\n    // 当进度条到达 95% 后停止增加\n    if (loadingBarWidth > MAX_LOADING_WIDTH) {\n      loadingBarWidth = MAX_LOADING_WIDTH;\n    }\n\n    progress.style.width = loadingBarWidth + '%';\n  }, 500);\n});\n\n// Pjax 完成之后执行的函数\ndocument.addEventListener('pjax:complete', function () {\n  clearInterval(timer);\n  progress.style.width = '100%';\n  loadingBar.classList.remove('loading');\n\n  setTimeout(function () {\n    progress.style.width = 0;\n  }, 400);\n});\n```\n\n上面的代码基本上实现了 Github 中 Pjax 加载进度条的效果，仅供参考。具体效果可以在我的[个人博客](https://liuyib.github.io/)上体验一下。\n\n### 重载 JS 脚本\n\n**这里的重载指的是重新加载**。由于通过 Pjax 切换的页面并没有完全刷新，浏览器不会将网页从头执行一遍，因此有些 JS 将不会生效。重载 JS 脚本大致分为三种：一种是重载 JS 函数，一种是重载整个 JS 文件，另一种是重载内联的 `script` 标签。\n\n1. 重载 JS 函数\n\n这种重载一般适用于用户自己编写的一些 JS 函数。但是具体情况比较复杂，函数要不要重载还得具体分析。下面举一些例子：\n\n- 页面不变部分对应的事件\n\n比如，页面顶部栏有一个搜索按钮，点击之后会弹出搜索框：\n\n``` js\ndocument.querySelector('.search-button').onclick = function () {\n  // ...\n};\n```\n\n由于页面顶部栏不变，所以其中的元素上绑定的事件仍然可以使用，这部分元素对应的 JS 事件不需要重载。\n\n- 页面可变部分对应的事件\n\n比如，页面主体部分是变化的，懒加载其中的图片：\n\n``` js\nvar imgs = document.querySelectorAll('#main img.lazyload');\n\nlazyload(imgs);\n```\n\n当通过 Pjax 切换页面后，由于主体部分改变，上述代码已经失效，因此需要进行重载。为了方便使用，我们使用函数封装一下：\n\n``` js\nfunction pjax_reload() {\n  var imgs = document.querySelectorAll('#main img.lazyload');\n\n  lazyload(imgs);\n}\n\n// Pjax 完成后，重新加载上面的函数\ndocument.addEventListener('pjax:complete', function (){\n  pjax_reload();\n});\n```\n\n2. 重载整个 JS 文件\n\n这种情况多数用于第三方文件，比如，卜算子统计的脚本、谷歌/百度/腾讯分析的脚本等，这些脚本在每一次页面加载后都需要执行。\n\n我的做法是，在引入这些文件的标签上添加 `data-pjax` 属性，然后将具有这个属性的标签重新添加在页面中。有时候不方便在这些标签上添加额外的属性，那么你可以在这些标签外套一层标签，如 `<div class=\".pjax-reload\"></div>`，然后将 `.pjax-reload` 里的元素全部重新添加到页面中即可。代码示例如下：\n\n``` html\n<script data-pjax src=\"https://cdn.jsdelivr.net/gh/sukkaw/busuanzi/bsz.pure.mini.js\"></script>\n\n<div class=\".pjax-reload\">\n  <script src=\"https://www.google-analytics.com/analytics.js\"></script>\n</div>\n```\n\n``` js\n// jQuery 写法\n$('script[data-pjax], .pjax-reload script').each(function () {\n  $(this).parent().append($(this).remove());\n});\n\n// JS 写法\ndocument.querySelector('script[data-pjax], .pjax-reload script').forEach(function (elem) {\n  var id = element.id || '';\n  var src = element.src || '';\n  var code = element.text || element.textContent || element.innerHTML || '';\n  var parent = element.parentNode;\n  var script = document.createElement('script');\n\n  parent.removeChild(element);\n\n  if (id !=='') {\n    script.id = element.id;\n  }\n\n  if (src !== '') {\n    script.src = src;\n    script.async = false;\n  }\n\n  if (code !== '') {\n    script.appendChild(document.createTextNode(code));\n  }\n\n  parent.appendChild(script);\n});\n```\n\n看到两种写法的差距，感觉整个人都不好了。\n\n3. 重载整个 `script` 标签\n\n这种情况和前面类似，如果一些 JS 脚本写在 `script` 标签中，并且需要重载，可以选择直接重载整个 `script` 标签。具体做法和上一步相同，在标签上添加 `data-pjax` 属性，然后将具有这个属性的标签重新添加到页面中。\n\n## 总结\n\n本文主要介绍了 Pjax 的基本用法，和一些常见问题的解决方法。下面，赶快动起手来，让你的网站使用 Pjax 吧。\n\n---\n\n参考链接：\n\n- [pjax 是如何工作的？](https://www.zhihu.com/question/20289254)\n- [让你的网站实现 PJAX 无刷新](https://paugram.com/coding/add-pjax-to-your-website.html)\n","tags":["Pjax","第三方库","局部刷新"],"categories":["优化用户体验"]},{"title":"从 0 到 1 开发 Hexo 主题杂谈","url":"/2019/08/20/develop-hexo-theme-from-0-to-1/","content":"\n## 前言\n\n在没有开发自己的 Hexo 主题之前，我都是在 Github issues 里写[博客](https://github.com/liuyib/blog/issues)，但这样的做法总被小伙伴各种吐槽 (￣_￣ )。想到如果文章多的时候，使用 Github issues 浏览起来不够方便，所以还是换回了 Hexo。\n\n使用 Hexo 首先是要挑选喜欢的主题，以我个人的感受来讲，Hexo 的主题虽然有两百多个，但是能拿出手的也就不到二十个。其中我最佩服的主题 Next 已经足够优秀，但是风格我并不喜欢，最后决定自己开坑。\n\n本文主要记录了我从零开发 Hexo 主题 -- [Stun](https://github.com/liuyib/hexo-theme-stun) 时，遇到的所有坑和经验，**仅供参考**，有不足的地方欢迎指出。\n\n<!-- more -->\n\n## 知识储备\n\n### 模板引擎\n\n传统的 HTML 写起来既不方便，又不能复用，因此在 Hexo 中通常使用模板引擎来呈现网站内容。\n\n常用的几种模板引擎有：[Swig](https://github.com/paularmstrong/swig)、[EJS](https://github.com/hexojs/hexo-renderer-ejs)、[Haml](https://github.com/hexojs/hexo-renderer-haml) 或 [Jade](https://github.com/hexojs/hexo-renderer-jade)。其中 Jade 由于商标问题，改名为 [Pug](https://github.com/pugjs/pug)，虽然它们是兼容的，但使用的时候，推荐安装 Pug 而不是 Jade。Hexo 内置了 Swig，将文件扩展名改为 `.swig` 即可使用，你也可以安装插件来获得另外几种模板引擎的支持，Hexo 会根据文件扩展名来决定使用哪一种。例如：\n\n``` text\nlayout.pug   -- 使用 pug\nlayout.swig  -- 使用 swig\n```\n\n这里你需要做的是，选择一个自己喜欢的模板引擎，然后浏览文档，了解这个模板引擎的基本用法。\n\n- 英文文档地址分别如下：[Swig](https://node-swig.github.io/swig-templates/docs/)、[EJS](https://ejs.co/#docs)、[Pug](https://pugjs.org/api/getting-started.html)、[Haml](http://haml.info/docs.html)。\n- 中文文档地址分别如下：[Swig](https://myvin.github.io/swig.zh-CN/docs/index.html)、[EJS](https://ejs.bootcss.com/#docs)、[Pug](https://pugjs.org/zh-cn/api/getting-started.html)、Haml（无）。\n\n这里我选择了 Pug，不过我还是推荐使用 Swig 或 EJS。\n\n### CSS 预处理语言\n\n你可以使用原生 CSS 来写样式，但是原生 CSS 难以复用，不能使用循环，不能使用布尔判断，书写不够方便，等等。这会导致主题开发变得相对麻烦，甚至某些功能无法实现，因此最好是使用 CSS 预处理语言。\n\n常见的 CSS 预处理语言有：[Less](http://lesscss.org/)、[Sass](https://sass-lang.com/)、[Stylus](http://stylus-lang.com/)。至于它们的选择，根据自己的喜好即可。Hexo 默认使用的是 Stylus，它的功能足够强大，完全够用，因此我选用了 Stylus。\n\n### Hexo 相关知识\n\n有关 Hexo 的知识，这里只列举必要的部分。\n\n#### 构建 Hexo 开发环境\n\n开发主题之前，你需要搭建 Hexo 工作目录，有两种方式可供选择：\n\n1. 使用 `hexo-cli`\n2. 克隆 Hexo 主题的单元测试项目\n\n第一种方式，去 Hexo [官网](https://hexo.io/zh-cn/)，按照提示安装 `hexo-cli` 并生成你的 Hexo 工作目录，目录主要部分如下：\n\n``` text\n.\n├── scaffolds\n├── source\n|   └── _posts\n├── themes\n├── .gitignore\n├── _config.yml\n└── package.json\n```\n\n第二种方式，克隆 Hexo 官方的[单元测试库](https://github.com/hexojs/hexo-theme-unit-test)，这样会得到同上的文件目录。然后执行指令 `npm install` 安装所有依赖。\n\n对于一般的 Hexo 用户，基本都是使用第一种方式。不过对于 Hexo 主题开发者来说，如果你的主题将来要发布到 Hexo 的[主题列表](https://hexo.io/themes)，建议直接在 Hexo 的主题单元测试项目中进行开发，也就是第二种方式。因为 Hexo 建议在主题发布前，对主题进行单元测试，确保每一项功能都能正常使用。Hexo 提供的单元测试库包括了所有的边缘情况，例如：文章标题过长时的显示效果、文章标题为空时的显示效果（是什么都不显示，还是显示一些默认的提示文字）、对 Front-Matter 的支持程度，等等。直接使用 Hexo 主题的单元测试项目作为你的开发目录，就可以在开发过程中注意到这些边缘情况，而不是开发完再去测试。\n\n搭建完 Hexo 开发环境后，需要安装相关插件来支持你所使用的渲染引擎。Hexo 默认安装的渲染引擎是 EJS 和 Stylus，并且 Hexo 内置了 Swig，因此，如果你选用了 `EJS + Stylus` 或 `Swig + Stylus`，那么可以忽略这段，如果你选择了其他的渲染引擎，需要自行选择安装：\n\n``` bash\n# Templates\n$ npm install --save hexo-renderer-ejs\n$ npm install --save hexo-render-pug\n$ npm install --save hexo-render-haml\n\n# Styles\n$ npm install --save hexo-renderer-less\n$ npm install --save hexo-renderer-sass\n$ npm install --save hexo-renderer-stylus\n```\n\n#### 生成主题结构目录\n\n上一步只是搭建好了 Hexo 工作目录，接下来是创建主题的文件目录，你可以参考着已有的主题的文件目录手动创建，也可以使用 `Yeoman` 自动生成，使用 `Yeoman` 自动生成的步骤如下。\n\n1. 安装\n\n``` bash\n$ npm install --global yo\n$ npm install --global generator-hexo-theme\n```\n\n2. 生成\n\n进入 Hexo 的 `themes` 目录中，新建一个文件夹作为你的主题目录，然后进入该文件夹中，执行指令：\n\n``` bash\nyo hexo-theme\n```\n\n按照提示，填写或选择相应的信息，如下图：\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-theme-stun/doc/20190822211939.png)\n\n生成的文件目录如下：\n\n``` text\n.\n├── layout        # 布局文件夹\n|   ├── includes\n|   |   ├── layout.pug       # 页面总体布局\n|   |   └── recent-posts.pug # 文章列表\n|   ├── index.pug            # 首页\n|   ├── archive.pug          # 归档页\n|   ├── category.pug         # 分类页\n|   ├── tag.pug              # 标签页\n|   ├── post.pug             # 文章页\n|   └── page.pug             # 除以上页面之外的页面\n├── scripts       # 脚本文件夹\n├── source        # 资源文件夹\n|   ├── css\n|   ├── js\n|   └── favicon.ico\n├── .editorconfig # 编辑器配置文件\n├── _config.yml   # 主题配置文件\n└── package.json\n```\n\n当然只有这些文件目录是不够的，我们还需要另外添加一些其他的文件或目录，例如，`languages` 目录，放置语言文件，用于[国际化（i18n）](https://hexo.io/zh-cn/docs/internationalization)设置（如果你的主题需要支持多语言，就添加该目录，否则不用添加）。\n\n有关以上目录的介绍，详参见：[Hexo 主题](https://hexo.io/zh-cn/docs/themes)。\n\n> 这里需要提一下，主题目录和 Hexo 根目录中各有一个 `source` 文件夹，当你执行指令 `hexo generate` 来生成静态文件时，这两个 `source` 目录中的文件如果是 Markdown 文件，则会被解析为 HTML，而其他类型的文件则会被复制到 `public` 目录中。`public` 目录用于存放打包后生成的文件，这些文件就是线上跑的网站资源文件。**因此，如果你不清楚 `source` 目录里文件的使用路径是怎样的，那么你可以跑一下指令 `hexo generate`，这些文件生成到 `public` 目录中后，它们的路径关系就很明显了。**\n\n#### 通读文档\n\n虽然 Hexo 的文档确实很差劲，文档下面的评论区全是吐槽，而且有些部分中英文版本没有同步，但是如果能耐心读完，会有很大的收益，我个人的最大感受是 Hexo 的文档真的特别重要。当然一次掌握是不可能的，我的建议是在开发时每隔一段时间过一遍（Hexo 的一些重要功能，例如：标签插件、Front-Matter，等等，也只有通过阅读文档熟悉了之后，才能更好的实现和支持）。\n\n刚开始开发主题，不可能理解 Hexo 文档中提到的所有地方，但是有两个点必须首先掌握：[变量](https://hexo.io/zh-cn/docs/variables)和[辅助函数](https://hexo.io/zh-cn/docs/helpers)，这两点在开发时会经常用到，并且贯穿整个开发过程。\n\n## 主题开发\n\n有了上述的准备后，就可以开始主题的开发了。下面是主题开发中一些值得注意的地方，了解这些，可以帮助你避免踩重复的坑。\n\n### 主题配置文件\n\n主题的配置文件采用了 [Yaml](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html) 语法，和 Json 类似，了解一下语法格式就可以上手使用了。\n\n开发主题时，有的功能可以让用户自己配置，因此我们需要将这些功能的配置项暴露出来，填充到主题的配置文件 `_config.yml` 中。然后在模板引擎中，你可以通过 Hexo 内置的 `theme` 变量来获取这些配置项。例如：\n\n配置文件：\n\n``` yaml _config.yml\ncopyright:\n  enable: true\n  text:\n```\n\n这样使用：\n\n``` html\n// -------------------- Pug 语法 --------------------\nif theme.copyright.enable\n  div.copyright= theme.copyright.text\n\n// -------------------- Swig 语法 --------------------\n{% if theme.copyright.enable %}\n<div class=\"copyright\">{{ theme.copyright.text }}</div>\n{% endif %}\n```\n\n{% note default %}\n文章接下来的部分中，模板语言示例代码都会用 Pug 和 Swig 两种语法给出。\n{% endnote %}\n\n随着项目的发展，配置文件会越来越大，上面这种做法的缺点也会越来越明显。\n\n- 对于使用者\n\n  当更新主题时，由于配置文件会被覆盖，因此用户必须提前将配置文件备份，等更新完主题后再将备份的数据拷贝回去，这个过程繁琐又容易出错。\n\n- 对于开发者\n\n  在发布主题时，开发者不可能将自己测试用的数据保留在主题配置文件中，而应该预留一份干净的配置文件。因此每次发布主题之前，都需要把主题配置文件里的测试数据清空、备份，然后等发布完主题后再恢复回来。这种做法是无法令人忍受的，因为每次 `git commit` 之前都需要这样做一次。\n\n因此我们需要一种更友好的方式来使用配置文件。在查找资料和参考现有主题 NexT、Melody 的实现后，发现可以利用 Hexo 3.0 提供的新特性 -- [数据文件](https://hexo.io/zh-cn/docs/data-files)，来解决上面的痛点。\n\n使用方法如下，在 Hexo 根目录下的 `source/_data` 文件夹中（没有的文件夹需要自己创建），新建一个 Yaml 配置文件，并**命名为主题的名称**，例如 Stun 主题，就叫做 `stun.yml`。然后将主题配置文件 `_config.yml` 里的内容复制到 `stun.yml` 中，这样 `stun.yml` 就会覆盖 `_config.yml`。如果想要修改配置，直接修改 `stun.yml` 就好了。当用户更新主题或者开发者发布主题时，配置数据保存在 `stun.yml` 中，主题原来的配置文件 `_config.yml` 仍然是干净的。\n\n下面是代码实现，在主题根目录下的 `scripts` 文件夹中（没有就新建），添加一个 JS 文件，文件名随意，添加如下代码：\n\n``` js\nhexo.on('generateBefore', function () {\n  var rootConfig = hexo.config;\n\n  if (hexo.locals.get) {\n    // 获取 source/_data 目录下的文件\n    var data = hexo.locals.get('data');\n\n    // 如果存在 stun.yml 文件，就用它覆盖原来的配置文件\n    if (data && data.stun) {\n      hexo.theme.config = data.stun;\n    }\n  }\n\n  hexo.theme.config.rootConfig = rootConfig;\n});\n```\n\n### 页面搭建\n\n你需要分析主题页面的结构，将能够公用的部分抽离出来，例如：\n\n- HTML 的 `head` 部分\n- 顶部导航栏\n- 页面头部、底部\n- 页面侧边栏\n- 页面主体部分（显示文章的地方）\n- ......\n\n将这些部分对应的代码放在主题 `layout` 目录下的 `layout.pug` 文件中用以复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n  body\n    header#header.header\n      div.header-inner\n        include ./header.pug\n    \n    main#main.main\n      div.main-inner\n        div#content.content\n          div.content-inner\n            block content\n        \n        div#sidebar.sidebar\n          div.sidebar-inner\n            block sidebar\n\n    footer#footer.footer\n      div.footer-inner\n        include ./footer.pug\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n\n  <body>\n    <header id=\"header\" class=\"header\">\n      <div class=\"header-inner\">\n        {% include './header.swig' %}\n      </div>\n    </header>\n\n    <main id=\"main\" class=\"main\">\n      <div class=\"main-inner\">\n        <div id=\"content\" class=\"content\">\n          <div class=\"content-inner\">\n            {% block content %}{% endblock %}\n          </div>\n        </div>\n        \n        <div id=\"sidebar\" class=\"sidebar\">\n          <div class=\"sidebar-inner\">\n            {% block sidebar %}{% endblock %}\n          </div>\n        </div>\n      </div>\n    </main>\n\n    <footer id=\"footer\" class=\"footer\">\n      <div class=\"footer-inner\">\n        {% include './footer.swig' %}\n      </div>\n    </footer>\n  </body>\n</html>\n```\n\n`layout.pug` 是网站最基础的布局代码，所有的页面都是继承它而来。Pug / Swig 使用 `extends` 和 `block` 实现继承，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n\n  body\n    block content\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n  <body>\n    {% block content %}{% endblock %}\n  </body>\n</html>\n```\n\n``` html\n// -------------------- Pug 语法 --------------------\nextends layout.pug\n\nblock title\n  My Page\n\nblock content\n  This is a awesome page.\n\n// -------------------- Swig 语法 --------------------\n{% extends 'layout.swig' %}\n\n{% block title %}My Page{% endblock %}\n\n{% block content %}\n<p>This is a awesome page.</p>\n{% endblock %}\n```\n\n除了继承的方式复用代码，还可以通过 `include` 语法直接引文件来实现代码复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\ndiv#header.header\n  include ./header.pug\n\n// -------------------- Swig 语法 --------------------\n<div id=\"header\" class=\"header\">\n  {% include './header.swig' %}\n</div>\n```\n\n> 由于 `layout.pug` 只用于被其他页面继承，并不会单独渲染成页面，因此，可以将文件名改为 `_layout.pug`（以下划线开头）这样 Hexo 就不会解析这个文件，可以提高 Hexo 生成页面的速度。\n\n这里我并不准备介绍页面中更详细的部分如何实现，直接看[源码](https://github.com/liuyib/hexo-theme-stun)效果更好。\n\n### 数据交互\n\n这里介绍下 Pug / Swig、Stylus、JavaScript 这几种文件如何与主题配置文件进行数据交互。\n\n前面我们已经知道了，主题配置文件里的配置项被包含在 `theme` 变量下。因此在我们需要知道如何在另外三种文件中使用 `theme` 变量：\n\n- 在 Pug / Swig 文件中使用\n\n  ``` html\n  // -------------------- Pug 语法 --------------------\n  div= theme.copyright.text\n\n  html(lang=theme.language)\n\n  if theme.sidebar.enable\n    div.sidebar\n\n  div(class=`sidebar ${ if theme.sidebar.show ? 'show' : '' }`)\n\n  // -------------------- Swig 语法 --------------------\n  <div>{{ theme.copyright.text }}</div>\n\n  <html lang=\"{{ theme.language }}\"></html>\n\n  {% if theme.sidebar.enable %}\n    <div class=\"sidebar\"></div>\n  {% endif %}\n\n  <div class=\"sidebar {% if theme.sidebar.show %}show{% endif %}\"></div>\n  ```\n\n- 在 Stylus 文件中使用\n\n  需要通过 Hexo 内置的函数 `hexo-config` 来获取 `theme` 变量中的属性，但是不需要加 `theme.` 前缀：\n\n  ``` stylus\n  // back2top 是 theme 变量下的一个属性\n  if (hexo-config('back2top.enable'))\n    .back2top\n      display: block\n\n  // 如果配置项的值中含有样式，需要使用 Stylus 的 convert 函数转换一下\n  .post-title\n    color: convert(hexo-config('post.title.color'))\n  ```\n\n  > 在其他的 CSS 预处理语言中，理论上也可以通过 `hexo-config` 来获取 `theme` 变量中的属性，我没试过，开发者可以自行尝试。\n\n- 在 JavaScript 文件中使用\n\n  在 JS 文件中没有办法直接获取到 Hexo 内置的 `theme` 变量，但是我们可以换一种方式来间接获取。新建一个模板引擎文件，我们就叫它 `config.pug`，文件内容如下所示：\n\n  ``` html\n  // ----- Pug 语法（注意 script 标签后面的点，表示该标签后面有多行代码）-----\n  script.\n    var CONFIG = {\n      sidebar: '!{ theme.sidebar }',\n      back2top: '!{ theme.back2top }',\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n\n  // -------------------- Swig 语法 --------------------\n  <script>\n    var CONFIG = {\n      sidebar: {{ theme.sidebar | json_encode }},\n      back2top: {{ theme.back2top | json_encode }},\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n  </script>\n  ```\n\n  然后将 `config.pug` 文件放在 HTML 的 `head` 标签中加载，这样就可以通过全局变量 `CONFIG` 在 JS 中获取主题配置文件里的数据了。\n\n到这里为止，就介绍完了开发 Hexo 主题前必要的知识储备，剩下的就靠开发者自己完成了。\n\n## 发布主题\n\n发布主题之前你需要进行[主题单元测试](https://github.com/hexojs/hexo-theme-unit-test)，确保每一项功能都能正常使用。如果你是按照我之前介绍的方法，直接 Hexo 的主题单元测试库中开发主题，那么你应该就不需要进行这一步了。\n\n1、Fork [hexojs/site](https://github.com/hexojs/site)\n2、编辑 `source/_data/themes.yml`，在文件中新增您的主题：\n\n``` yaml themes.yml\n- name: Stun\n  description: A beautiful & simple theme\n  link: https://github.com/liuyib/hexo-theme-stun\n  preview: https://liuyib.github.io/\n  tags:\n    - responsive\n    - beautiful\n    - simple\n    - two_column\n```\n\n3、在 `source/themes/screenshots` 中添加一个和你主题同名的图片，图片必须为 800*500 的 PNG 文件。\n4、发起新的合并申请（pull request）。\n\n最后，只需要等待 Hexo 仓库的维护人员收录你的主题即可。\n\n---\n\n参考链接：\n\n- [Hexo主题开发经验杂谈](https://molunerfinn.com/make-a-hexo-theme/)\n- [Hexo 主题开发指南](http://chensd.com/2016-06/hexo-theme-guide.html)\n","tags":["Hexo"],"categories":["Hexo主题开发"]},{"title":"theme-stun-gitter","url":"/2019/07/26/theme-stun-gitter/","content":"\nThis is a link for Gitter of theme-stun. Clicking on the title to talking.\n"},{"title":"前端单元测试和持续集成","url":"/2019/06/04/front-end-unit-test-and-ci/","content":"\n经常使用 Github 的同学应该知道，一些开源项目中常常会挂上很多花花绿绿了的小徽章，比如 vue 的：\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131517.png)\n\n这些徽章不仅起到装饰 README 的作用，更给人以安全可靠的感觉。由于好奇，自己也探究了一番。\n\n## 给项目装上徽章\n\n想要获取徽章，有很多方式，最简单的可以通过 [shields.io](https://shields.io/) 网站获取，基本上想要的徽章都能获取到，没有的也可以进行 DIY，很方便。\n\n举个例子，将项目的开源协议通过徽章进行展示，你只需要填写 Github 用户名和项目名称，网站就会自动获取你项目中的数据。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131257.png)\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131255.png)\n\n然后你只需要复制链接，将徽章放入你的 README 即可。\n\n## 单元测试\n\n上面所说的开源协议这类徽章基本上只有展示作用，还有一些徽章，用户点击后，可以获取到他们想知道的数据，比如 `build passing`、`coverage 97%` 这些徽章是项目进行 CI（Continuous integration, 持续集成）测试和生成代码覆盖率报告后，展示出来的徽章。当用户点击它们，就可以看到项目 CI 测试的情况和代码覆盖率的报告图。\n\n为什么要展示代码覆盖率？原因很简单，代码覆盖率常常被认为是衡量单元测试好坏的一个指标，而单元测试的好坏在某种程度上又会反应项目代码的质量。因此当项目挂上 `coverage: 100%` 的徽章时，总给人以满满的安全感。\n\n那么为什么要进行单元测试，推荐看一个知乎上的优质回答：[单元测试到底是什么？应该怎么做？](https://www.zhihu.com/question/28729261/answer/163637881)。这里我只简单介绍一下前端单元测试的流程。\n\n前端的单元测试包括但不限于：单元功能测试、UI 测试、兼容性测试等等。一个测试体系大体包括四部分：\n\n- 测试运行器（eg: [karma](https://github.com/karma-runner/karma)）\n- 测试框架（eg: [mocha](https://github.com/mochajs/mocha), [jest](https://github.com/facebook/jest), [jasmine](https://github.com/jasmine/jasmine), [qunit](https://github.com/qunitjs/qunit)）\n- 断言库（eg: [should](https://github.com/shouldjs/should.js), [chai](https://github.com/chaijs/chai)）\n- 代码覆盖率（eg: [istanbul](https://github.com/gotwarlost/istanbul)）\n\n下面我们通过一个单元功能测试的例子来了解如果进行前端单元测试。\n\n> 举的这个例子没有涉及测试运行器，只讲了测试框架、断言库和测试覆盖率的使用。以我个人比较喜欢的 `mocha + should + istanbul` 组合为例。\n\n### 建立项目\n\n首先，执行 `npm init --yes` 创建 package.json 文件。\n\n然后，新建一个 main.js 文件，编写 factorial 函数，用于求一个数的阶乘。\n\n```js\nvar factorial = function(n) {\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n\nif (require.main === module) {\n  // 如果是直接执行 main.js，则进入此处\n  // 如果 main.js 被其他文件 require，则此处不会执行\n  var n = Number(process.argv[2]);\n  console.log(\"factorial(\" + n + \") is\", factorial(n));\n}\n```\n\n这只是简单的实现，我们先运行一下，看看结果是否正确。执行指令：`node main.js 5`，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604172016.png)\n\n结果是 120，符合预期。但是一个测试例子并不能说明什么，我们还需要验证如果输入，负数、非数字、小数、很大的数等等，程序会返回什么。所以接下来我们将进行 **测试驱动开发**（Test-Driven Development, TDD），通过不断的测试来逐步完善我们的代码。\n\n### 运行测试\n\n在 main.js 中添加一句 `exports.fibonacci = fibonacci;` 将函数暴露出去。这样才可以在其他文件中 `require` 这个函数。\n\n在 test 目录下新建测试文件，命名为 `main.test.js`。然后在测试文件中引用 fibonacci 函数，并使用 mocha 和 should 进行测试。\n\n> 测试文件通常放在 test 目录下，文件的命名规则是在原来的文件名后面加 `.test`\n\n```js\nvar main = require(\"../src/main\");\nvar should = require(\"should\");\n\ndescribe(\"test/main.js\", function() {\n  it(\"should equal 0 when n === 0\", function() {\n    main.factorial(0).should.equal(1);\n  });\n});\n```\n\n> 其中 `describe()`、`it()` 是 mocha 提供的 api，看不懂的话先记住就好了。\n\n接着我们来跑通测试文件。\n\n首先全局安装 mocha：`npm install mocha -g`，然后执行指令：`mocha ./test/main.test.js`，结果如下，显示 passing 表明测试通过。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604175056.png)\n\n到这里，我们已经使用测试框架 + 断言库进行了最简单的测试，接下来需要不断完善测试用例来使我们的代码健壮起来。\n\n### 完善测试用例\n\n首先，明确函数功能。我们的 factorial 函数应该有以下功能。\n\n- 当 n === 0 时，返回 1。\n- 当 n > 0 时，返回 `factorial(n - 1) * n`。\n- 当 n < 0 时，抛出错误。因为没有意义。\n- 当 n 不是数字时，抛出错误。\n- 当 n > 10 时，抛出错误。这里为了演示，只进行 10 以内的阶乘运算。\n\n然后，我们需要根据功能来完善测试用例。\n\n```js\ndescribe(\"test/main.js\", function() {\n  it(\"should equal 1 when n === 0\", function() {\n    main.factorial(0).should.equal(1);\n  });\n\n  it(\"should equal 1 when n === 1\", function() {\n    main.factorial(1).should.equal(1);\n  });\n\n  it(\"should equal 3628800 when n === 10\", function() {\n    main.factorial(10).should.equal(3628800);\n  });\n\n  it(\"should throw when n > 10\", function() {\n    (function() {\n      main.factorial(11);\n    }.should.throw(\"n should <= 10\"));\n  });\n\n  it(\"should throw when n < 0\", function() {\n    (function() {\n      main.factorial(-1);\n    }.should.throw(\"n should >= 0\"));\n  });\n\n  it(\"should throw when n is not Number\", function() {\n    (function() {\n      main.factorial(\"参数类型错误\");\n    }.should.throw(\"n should be a Number\"));\n  });\n});\n```\n\n接着，执行测试指令 `mocha ./test/main.test.js`，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604181013.png)\n\n可以看到后面三个测试用例都没有通过，这说明 factorial 函数并不是在所有情况下都可以正常运行。所以我们更新 factorial 的实现。\n\n```js\nvar factorial = function(n) {\n  if (typeof n !== \"number\") {\n    throw new Error(\"n should be a Number\");\n  }\n\n  if (n < 0) {\n    throw new Error(\"n should >= 0\");\n  }\n\n  if (n > 10) {\n    throw new Error(\"n should <= 10\");\n  }\n\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n```\n\n然后再次执行测试指令，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604191932.png)\n\n完美通过测试。这就是测试驱动开发的流程，首先明确程序的功能，然后跑测试用例，如果测试用例没有通过，修改程序，直到测试用例通过。\n\n### 生成代码覆盖率\n\n有一个指标用于检测编写的测试用例是否合理。这个指标叫做 “代码覆盖率”。它包含四个方面。\n\n- **行覆盖率**：是否每一行都执行了\n- **函数覆盖率**：是否每个函数都调用了\n- **分支覆盖率**：是否每个 if 代码块都执行了\n- **语句覆盖率**：是否每个语句都执行了\n\n这里我们使用 istanbul 来生成代码覆盖率。首先全局安装 istanbul：`npm install istanbul -g`，执行指令：`istanbul cover _mocha`（如果这条指令执行时报错，那就将 mocha 项目级安装：`npm install mocha --save-dev`，然后执行指令：`istanbul cover ./node_modules/mocha/bin/_mocha`）\n\n> 注意，这条指令中 `_mocha` 前面的下划线不能省略。因为，mocha 和 \\_mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604200739.png)\n\n具体的覆盖率情况，可以运行 `coverage/lcov-report` 目录下的 `index.html` 文件查看。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604201523.png)\n\n其实这次的覆盖率是 100%，因为函数在被其他文件引用时 24、25 这两行不会执行，所以没办法测。如果将这两行所在的 if 语句删除，可以得到 100% 的覆盖率。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604201923.png)\n\n### 上传代码覆盖率\n\n主流的的展示代码覆盖率的工具有 [Codecov](https://codecov.io/) 和 [Coveralls](https://coveralls.io/)。至于选择哪一个，答案是都可以，不过 Coveralls 网站的界面有种古典的气息，相比之下我更喜欢 Codecov，所以这里以 Codecov 为例。\n\n首先，打开 Codecov 官网，绑定 Github 账号之后，选择要展示覆盖率的仓库。\n\n然后，项目级安装 codecov：`npm install codecov --save-dev`。\n\n接着，将上传覆盖率的指令写入 `package.json` 文件。\n\n```json\n\"script\": {\n  \"codecov\": \"cat ./coverage/lcov.info | ./node_modules/.bin/codecov\"\n}\n```\n\n这条指令中 `cat ./coverage/lcov.info` 指令用于读取 coverage 目录下的 `lcov.info` 文件， `./node_modules/.bin/codecov` 指令用于将覆盖率上传到 Codecov 网站。\n\n> 注意，上传覆盖率的指令在本地运行是没有作用的，需要在 CI 中执行才有效。\n\n下面会讲如何在 CI 中上传代码覆盖率。\n\n## 持续集成\n\n了解了单元测试和代码覆盖率后，这还不够，因为我们不可能每次都手动运行测试脚本，我们需要的是自动化测试。这就涉及到了持续集成的概念。\n\n持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n主流的持续集成工具有 [Travis CI](https://travis-ci.org/) 和 [Circle CI](https://circleci.com/)，个人比较喜欢前者，因此这里以 Travis CI 为例。\n\n### Travis CI 的使用\n\n首先，进入官网后，点击 Sign In 按钮绑定 Github。然后在仓库列表中选择你要进行持续集成的仓库，点击按钮启用。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604205207.png)\n\n然后，你需要在项目根目录下创建 `.travis.yml` 文件（如果没有这个文件，Travis 会默认执行 `npm install` 和 `npm test`），配置文件示例如下。\n\n```yml\nlanguage: node_js\n\nnode_js:\n  - 10\n\n# Travis CI cache\ncache:\n  directories:\n    - node_modules\n\ninstall:\n  - npm install\n\nscript:\n  - npm run coverage\n\nafter_success:\n  - npm run codecov\n\nbranches:\n  only:\n    - master\n```\n\n在这个配置文件中，指定了我们代码的语言（languages），语言版本（node_js），构建之前运行什么指令安装依赖包（install），执行测试程序的指令（script），测试指令执行成功后执行的指令（after_success）以及对项目的哪些分支进行测试（branches）。更多的配置请查看 Travis 的[官方文档](https://docs.travis-ci.com/user/tutorial/)。\n\n此外这里还使用了 Travis 的 cache 功能缓存 npm 包，来节省构建时间。\n\n上面配置文件中的 `npm run coverage` 和 `npm run codecov` 指令定义在 `package.json` 文件里。\n\n```json\n\"scripts\": {\n  \"coverage\": \"./node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -R spec\",\n  \"codecov\": \"cat ./coverage/lcov.info | ./node_modules/.bin/codecov\"\n}\n```\n\n此外我们还需要将用到的测试库项目级安装。\n\n```bash\nnpm install --save-dev codecov istanbul mocha should\n```\n\n> 也就是说，你项目的 package.json 文件中的 `devDependencies` 字段或 `dependencies` 字段里，要有这些用到的库的信息才行，这样 CI 执行 `npm run install` 时，才能安装它们，否则会找不到 `istanbul`、`mocha`、`codecov` 这些指令。\n\n如果你 `.travis.yml` 文件中的 install 字段配置如下。\n\n```yml\ninstall:\n  - npm install\n  - npm install istanbul -g\n  - npm install codecov -g\n```\n\n那么 `npm run coverage` 和 `npm run codecov` 指令就可以修改为。\n\n```json\n\"scripts\": {\n  \"coverage\": \"istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -R spec\",\n  \"codecov\": \"cat ./coverage/lcov.info | codecov\"\n}\n```\n\n> 这里建议不要将 mocha 全局安装，而且依赖包最好都项目级安装。\n\n### 展示徽章\n\n实现了 CI，也上传了代码覆盖率，接下来我们只需要将结果以徽章的形式放入 READMD 即可。\n\nTravis 的徽章这样获取：\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604225243.png)\n\nCodecov 的徽章这样获取：\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604225017.png)\n\n每当项目 commit 之后，CI 测试就会自动进行，然后测试的结果就会通过徽章展示在你的项目文档中。\n\n### 跨浏览器集成测试\n\n浏览器端使用的库，在各个浏览器端的兼容性也是非常重要的。一些项目会选择在模拟环境中进行测试，这样虽然方便，但是毕竟是模拟的，测试效果无法媲美真实环境。所以就需要用到跨浏览器测试的工具，有两个选择 [SauceLabs](https://saucelabs.com/) 和 [BrowserStack](https://www.browserstack.com/)，这个工具提供了多重的浏览器环境（包括 PC 端和移动端），帮助你在多种浏览器中自动运行脚本。\n\n关于跨浏览器集成测试，这里不再叙述。\n","tags":["单元测试","持续集成","Github徽章"],"categories":["前端自动化"]}]